
ext {
    // package patterns to exclude from Eclipse
    excludeFromEclipse = []
}


// -------------------------------------------
//  REPOSITORIES
// -------------------------------------------

repositories {
    // prefer locally built artifacts
    mavenLocal()

    // use external repos as fallback
    mavenCentral()
}

tasks.named('test') {
    // enable JUnit 5 tests
    useJUnitPlatform()
}


// -------------------------------------------
//  JAVA TOOLCHAIN
// -------------------------------------------

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}


// -------------------------------------------
//  JAVA COMPILER
// -------------------------------------------

tasks.withType(JavaCompile).configureEach {
    // always UTF-8
    options.encoding = 'UTF-8'

    // export names of constructor and method parameter names
    options.compilerArgs << "-parameters"

    options.compilerArgs << '-Xlint:unchecked'

    if (project.plugins.hasPlugin('net.ltgt.errorprone')) {
        // Eclipse code formatting removes extraneous parenthesis which errorprone complains about
        options.errorprone.disable 'OperatorPrecedence'

        // we don't need to check return value always
        options.errorprone.disable 'FutureReturnValueIgnored'

        // generated code can have lots of bogus warnings
        options.errorprone.disableWarningsInGeneratedCode = true

        // bogus warning
        options.errorprone.disable 'StringSplitter'

        // ignore all generated source folders
        options.errorprone.excludedPaths = '.*generated.*'
    }
}


// -------------------------------------------
//  ECLIPSE
// -------------------------------------------

eclipse {
    classpath {
        // override default 'bin'
        defaultOutputDir = project.file('bin/classes')

        // we want source files
        downloadSources = true
        downloadJavadoc = false

        // customize generated .classpath file
        file {
            def project_refs = []
            def remove_entries = []

            // closure executed after .classpath content is loaded from existing file
            // and after gradle build information is merged
            whenMerged { classpath ->

                // build list of dependencies that we want to replace with Eclipse project refs
                println 'Finding local projects'
                def use_eclipse_project_refs = []
                new File(project.projectDir, "..").eachDir {
                    if(new File("${it}/build.gradle").exists()) {
                        use_eclipse_project_refs.add it.name
                    }
                }

                println 'Generating Eclipse .classpath file'
                def kindOrder = [ 'src':1, 'con':2, 'lib':3, 'output':0 ];
                classpath.entries.sort(true, { a,b ->
                    def order = kindOrder[a.kind] <=> kindOrder[b.kind]
                    order != 0 ? order : a.path <=> b.path
                } as Comparator).each { entry ->
                    if(entry.kind.equals('lib')) {
                        use_eclipse_project_refs.each { name ->
                            def regex = '/(' + ( name.endsWith('-') ?
                                    java.util.regex.Pattern.quote(name.substring(0,name.length()-1)) + '(?:-[A-Za-z]+)*'
                                    : java.util.regex.Pattern.quote(name) ) + ')-([\\w\\.]+?)(-[A-Za-z]+)?\\.jar$'
                            def pattern = java.util.regex.Pattern.compile(regex)
                            def matcher = pattern.matcher(entry.path)
                            if(matcher.find()) {
                                def match = matcher.group(1)
                                println match + ' (' + matcher.group(2) + ') matched ' + entry.path
                                remove_entries += [entry]
                                project_refs += [match]
                            }
                        }
                        entry.exported = true
                    } else if(entry.kind.equals('src')) {
                        project.ext.excludeFromEclipse.each { path ->
                            if(entry.path.equals(path)) {
                                remove_entries += [entry]
                            }
                        }
                    }
                }
                classpath.entries.removeAll(remove_entries)
            }

            // final adjustments to .classpath file before it is saved
            withXml { xml ->
                def node = xml.asNode()

                project_refs.unique(false).each { name ->
                    println "Creating Eclipse project dependency: " + name
                    node.appendNode('classpathentry', [ combineaccessrules: false, exported: true, kind: 'src', path: '/' + name ])
                }

                def apt = ['.apt_generated_test': 'bin/test',
                           '.apt_generated':      'bin/main']

                apt.each { path, output ->
                    def atts = node.appendNode('classpathentry', [kind:'src', output: output, path: path]).appendNode('attributes')
                    atts.appendNode('attribute', [name: 'ignore_optional_problems', value: true])
                    atts.appendNode('attribute', [name: 'test', value: output.contains('test')])
                    atts.appendNode('attribute', [name: 'optional', value: true])
                }
            }
        }
    }
}


// -------------------------------------------
//  ECLIPSE FACTORY PATH (for annotation processing)
// -------------------------------------------

tasks.register('eclipseFactoryPath') {
    description = 'Generates the .factorypath file for Eclipse annotation processing'

    doLast {
        def factorypath = new File(projectDir, '.factorypath')
        factorypath.withWriter { writer ->
            writer.writeLine '<?xml version="1.0" encoding="UTF-8"?>'
            writer.writeLine '<factorypath>'
            configurations.annotationProcessor.resolvedConfiguration.resolvedArtifacts.each { artifact ->
                writer.writeLine "    <factorypathentry kind=\"EXTJAR\" id=\"${artifact.file.absolutePath}\" enabled=\"true\" runInBatchMode=\"false\" />"
            }
            writer.writeLine '</factorypath>'
        }
        println "Generated ${factorypath}"
    }
}


// -------------------------------------------
//  README
// -------------------------------------------

tasks.register('readme') {
    doLast {
        def readmeFile = file('README.md')
        def content = readmeFile.text
        content = content.replaceAll(/<version>[0-9.]+<\/version>/, "<version>${version}</version>")
        content = content.replaceAll("com\\.arakelian:" + project.name + ":[0-9.]+", "com.arakelian:${project.name}:${version}")
        readmeFile.text = content
    }
}


// -------------------------------------------
//  LIFECYCLE TASKS
// -------------------------------------------

tasks.register('classpath') {
    dependsOn 'cleanEclipseClasspath', 'eclipseClasspath',
              'eclipseFactoryPath', 'cleanIdeaModule', 'ideaModule'
}

// ensure clean tasks run before generate tasks
tasks.named('eclipseClasspath') { mustRunAfter 'cleanEclipseClasspath' }
tasks.named('ideaModule') { mustRunAfter 'cleanIdeaModule' }

tasks.register('all') {
    dependsOn 'clean', 'classpath', 'build', 'publishToMavenLocal'
}

// ensure proper execution order
tasks.named('classpath') { mustRunAfter 'clean' }
tasks.named('build') { mustRunAfter 'classpath' }
tasks.named('publishToMavenLocal') { mustRunAfter 'build' }
